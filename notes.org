#+TITLE: Let's Build an Interpreter

Interpreter Tutorial after:
https://ruslanspivak.com/lsbasi-part1/

* Interpreter
** Concepts
*** Token
Stores a type and a value
Example:
#+BEGIN_SRC python
INTEGER, PLUS, EOF = 'INTEGER', 'PLUS', 'EOF'

class Token(object):
    def __init__(self, type, value):
        self.type = type
        self.value = value

token = Token(INTEGER, 1)
#+END_SRC

*** Lexical Analyzer (Lexer)
Convert string to tokenstream
*** Parsing
Finding structure in the tokenstream
** Helpers
*** Syntax Diagrams
#+attr_org: :width 500px
#+CAPTION: Simple syntax diagram for calculator
[[file:images/syntax_diagram.png][Example]]

*** (E)BNF (context-free grammars)
Modified EBNF notation:

expr    : factor ((MUL | DIV) factor)*
factor  : INTEGER

- A grammar consists of a sequence of *rules* (productions)
- A rules consists of a non-terminal the *head*(left-hand) and a sequence of terminals the *body*(right-hand)
- tokens are *terminals*
- the non-terminal on the left side of the first rule is the *start symbol*
- Make code from grammar:
  1. Each rule, R, defined in the grammar, becomes a method with the same name, and references to that rule become a method call: R(). The body of the method follows the flow of the body of the rule using the very same guidelines.
  2. Alternatives (a1 | a2 | aN) become an if-elif-else statement
  3. An optional grouping (â€¦)* becomes a while statement that can loop over zero or more times
  4. Each token reference T becomes a call to the method eat: eat(T). The way the eat method works is that it consumes the token T if it matches the current lookahead token, then it gets a new token from the lexer and assigns that token to the current_token internal variable.
**** Precedence Table
***** Example:
|------------+---------------+-----------|
| precedence | associativity | operators |
|      level |               |           |
|------------+---------------+-----------|
|          2 | left          | +, -      |
|          1 | left          | *, /      |
|------------+---------------+-----------|

expr      :  term ((PLUS | MINUS) term)*
term      :  factor ((MUL | DIV) factor)*
factor    :  INTEGER

***** Construct grammar from precedence
1. For each level of precedence define a non-terminal. The body of a production for the non-terminal should contain arithmetic operators from that level and non-terminals for the next higher level of precedence.
2. Create an additional non-terminal factor for basic units of expression, in our case, integers. The general rule is that if you have N levels of precedence, you will need N + 1 non-terminals in total: one non-terminal for each level plus one non-terminal for basic units of expression.

* Dice Rules
** Examples
|-----------------------+-------------+----------------------------------------|
| Example               | Rule        | Result                                 |
|-----------------------+-------------+----------------------------------------|
| 1d6                   | NdA         | Throw N dice of value A                |
| 2 + 2                 | x + y       | add x to y                             |
| 2 - 3                 | x - y       | subtract 3 from 2 and cap to 0         |
| 1d20 + 2 >= 18        | a > b       | boolean comparision                    |
| 1d20 >= 15 -> 1d6 + 2 | if a then b | if left side is true return right side |
|-----------------------+-------------+----------------------------------------|

** Precedence
Reduced Instruction Set: +, >=, d
|------------+------------------|
| precedence | operators        |
|      level |                  |
|------------+------------------|
|          4 | ->               |
|          3 | >=, <=, <, >, == |
|          2 | +, -             |
|          1 | d                |
|------------+------------------|

** Grammar
expr      :  throw (IF_THEN throw)?
throw     :  side (GREATER_THEN side)?
side      :  term (PLUS term)*
term      :  factor (d factor)?
factor    :  INTEGER
